using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using FotM.Domain;
using FotM.TestingUtilities;
using FotM.Utilities;
using MoreLinq;
using NUnit.Framework;
using Microsoft.VisualStudio.TestTools.UnitTesting;

namespace FotM.Cassandra.Tests
{
    /// <summary>
    /// This class will test prediction(derivation?) accuracy of Cassandra based on 
    /// autogenerated history.
    /// </summary>
    [TestFixture]
    [TestClass]
    public class CassandraSuperTests: ArmoryTestingBase
    {
        private readonly Realm[] _realms = new Realm[]
        {
            new Realm() { RealmId = 0, RealmSlug = "0", RealmName = "Zero"},
            new Realm() { RealmId = 1, RealmSlug = "1", RealmName = "Two"},
            new Realm() { RealmId = 2, RealmSlug = "2", RealmName = "Three"},
            new Realm() { RealmId = 3, RealmSlug = "3", RealmName = "Four"},
            new Realm() { RealmId = 4, RealmSlug = "4", RealmName = "Five"},
        };

        public CassandraSuperTests() : base(Bracket.Threes)
        {
        }

        LeaderboardEntry[] GeneratePlayers(int nPlayers)
        {
            var rnd = new Random();

            return Enumerable.Range(0, nPlayers)
                .Select(i =>
                {
                    int nRealm = rnd.Next(5);

                    return new LeaderboardEntry()
                    {
                        ClassId = rnd.Next(10),
                        FactionId = rnd.Next(2),
                        GenderId = rnd.Next(2),
                        RaceId = rnd.Next(5),
                        Name = Guid.NewGuid().ToString(),
                        Ranking = rnd.Next(1, 1000),
                        Rating = rnd.Next(1900, 2400),
                        RealmId = _realms[nRealm].RealmId,
                        RealmName = _realms[nRealm].RealmName,
                        RealmSlug = _realms[nRealm].RealmSlug,
                        WeeklyWins = rnd.Next(10),
                        WeeklyLosses = rnd.Next(10),
                        SeasonLosses = 10+rnd.Next(50),
                        SeasonWins = 10+rnd.Next(50)
                    };
                })
                .ToArray();
        }

        Team[] GenerateTeams(LeaderboardEntry[] entries)
        {
            const int teamSize = 3;

            /* Generate teams from players of the same realm */
            var playersPerRealm = entries
                .Select(e => e.Player())
                .GroupBy(p => p.Realm);

            List<Team> teams = new List<Team>();

            foreach (var realm in playersPerRealm)
            {
                var players = realm.ToArray();

                int nTeams = players.Length / teamSize;

                for (int i = 0; i < nTeams; ++i)
                {
                    var teamPlayers = new List<Player>();

                    for (int j = 0; j < teamSize; ++j)
                    {
                        teamPlayers.Add(players[i * teamSize + j]);
                    }

                    teams.Add(new Team(teamPlayers));
                }
            }

            return teams.ToArray();
        }

        Dictionary<Leaderboard, HashSet<Team>> GenerateHistory(Team[] teams, LeaderboardEntry[] startingEntries, int length)
        {
            var rnd = new Random();

            var leaderboard = CreateLeaderboard(startingEntries);

            var results = new Dictionary<Leaderboard, HashSet<Team>>();
            results[leaderboard] = new HashSet<Team>();

            for (int i = 0; i < length; ++i)
            {
                // Select subset of teams that will play
                int nTeamsPlayedThisTurn = 10;//3+rnd.Next(10);

                Team[] playingTeams = teams.Shuffle().Take(nTeamsPlayedThisTurn).ToArray();

                // For each of them generate rating change, update players and create new leaderboard
                var updatedEntries = new List<LeaderboardEntry>();

                foreach (var playingTeam in playingTeams)
                {
                    int ratingChange = rnd.Next(-30, 30);

                    foreach (var player in playingTeam.Players)
                    {
                        var previousEntry = leaderboard.Rows.FirstOrDefault(r => r.Player().Equals(player));
                        var updatedEntry = UpdateEntry(previousEntry, ratingChange);
                        updatedEntries.Add(updatedEntry);
                    }
                }

                // Fill it
                var updatedPlayers = playingTeams.SelectMany(t => t.Players).ToHashSet();
                var oldEntries = leaderboard.Rows.Where(r => !updatedPlayers.Contains(r.Player()));

                var newLeaderboard = new Leaderboard
                {
                    Time = DateTime.Now, 
                    Bracket = this.Bracket,
                    Rows = oldEntries.Union(updatedEntries).ToArray()
                };

                newLeaderboard.Order();

                // Remember who really played this turn
                results[newLeaderboard] = playingTeams.ToHashSet();

                leaderboard = newLeaderboard;
            }

            return results;
        }

        [Test]
        [TestMethod]
        public void CalculateDerivationAccuracy()
        {
            LeaderboardEntry[] startingEntries = GeneratePlayers(1000);
            Team[] teams = GenerateTeams(startingEntries);
            var history = GenerateHistory(teams, startingEntries, 500);

            int totalChanges = 0;
            int correctlyDerived = 0;

            var previousLeaderboard = history.First().Key;

            foreach (var step in history.Skip(1))
            {
                var leaderboard = step.Key;
                var expectedTeams = step.Value;

                totalChanges += expectedTeams.Count;

                var cassandra = new Cassandra();
                var derivedTeams = cassandra.FindTeams(previousLeaderboard, leaderboard);

                correctlyDerived += derivedTeams.Intersect(expectedTeams).Count();

                previousLeaderboard = leaderboard;
            }

            double accuracy = correctlyDerived/(double) totalChanges;
            string msg = string.Format("Cassandra accuracy: {0}", accuracy);
            Trace.WriteLine(msg);
        }
    }
}
