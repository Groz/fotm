using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using FotM.Domain;
using FotM.TestingUtilities;
using FotM.Utilities;
using MoreLinq;
using NUnit.Framework;
using Microsoft.VisualStudio.TestTools.UnitTesting;

namespace FotM.Cassandra.Tests
{
    /// <summary>
    /// This class will test prediction(derivation?) accuracy of Cassandra based on 
    /// autogenerated history.
    /// </summary>
    [TestFixture]
    [TestClass]
    public class CassandraSuperTests: ArmoryTestingBase
    {
        const int TeamSize = 3;
        private static readonly Random Rng = new Random(367);

        private static readonly Realm[] Realms = new Realm[]
        {
            new Realm() { RealmId = 0, RealmSlug = "0", RealmName = "Zero"},
            new Realm() { RealmId = 1, RealmSlug = "1", RealmName = "Two"},
            new Realm() { RealmId = 2, RealmSlug = "2", RealmName = "Three"},
            new Realm() { RealmId = 3, RealmSlug = "3", RealmName = "Four"},
            new Realm() { RealmId = 4, RealmSlug = "4", RealmName = "Five"},
        };

        public CassandraSuperTests() : base(Bracket.Threes)
        {
        }

        public static LeaderboardEntry[] GeneratePlayers(int nPlayers)
        {
            return Enumerable.Range(0, nPlayers)
                .Select(i =>
                {
                    int nRealm = Rng.Next(5);

                    var guid = new byte[16];
                    Rng.NextBytes(guid);

                    return new LeaderboardEntry()
                    {
                        ClassId = Rng.Next(10),
                        FactionId = 0,
                        GenderId = Rng.Next(2),
                        RaceId = Rng.Next(5),
                        Name = new Guid(guid).ToString().Substring(0, 5),
                        Ranking = Rng.Next(1, 1000),
                        Rating = Rng.Next(2100, 2300),
                        RealmId = Realms[nRealm].RealmId,
                        RealmName = Realms[nRealm].RealmName,
                        RealmSlug = Realms[nRealm].RealmSlug,
                        WeeklyWins = 0,
                        WeeklyLosses = 0,
                        SeasonLosses = 0,
                        SeasonWins = 0
                    };
                })
                .ToArray();
        }

        public static Team[] GenerateTeams(LeaderboardEntry[] entries)
        {
            /* Generate teams from players of the same realm */
            var playersPerRealm = entries
                .Select(e => e.Player())
                .GroupBy(p => p.Realm);

            List<Team> teams = new List<Team>();

            foreach (var realm in playersPerRealm)
            {
                var players = realm.Shuffle(Rng).ToArray();

                int nTeams = players.Length / TeamSize;

                for (int i = 0; i < nTeams; ++i)
                {
                    var teamPlayers = new List<Player>();

                    for (int j = 0; j < TeamSize; ++j)
                    {
                        teamPlayers.Add(players[i * TeamSize + j]);
                    }

                    teams.Add(new Team(teamPlayers));
                }
            }

            return teams.ToArray();
        }

        Leaderboard Play(Leaderboard leaderboard, Team[] playingTeams, Func<Team, int> ratingChange)
        {
            var updatedEntries = new List<LeaderboardEntry>();

            foreach (var playingTeam in playingTeams)
            {
                var previousPlayerEntries =
                    playingTeam.Players.Select(
                        player => leaderboard.Rows.FirstOrDefault(r => r.Player().Equals(player)))
                        .OrderByDescending(p => p.Rating)
                        .ToArray();

                int teamRatingChange = ratingChange(playingTeam);

                for (int iPlayer = 0; iPlayer < TeamSize; ++iPlayer)
                {
                    var previousEntry = previousPlayerEntries[iPlayer];

                    // higher rated players gain less rating and lose more
                    int playerRatingChange = teamRatingChange;

                    if (playerRatingChange > 0)
                    {
                        playerRatingChange += iPlayer; // add 0, 1 or 2
                    }
                    else
                    {
                        playerRatingChange -= TeamSize - iPlayer; // decrease rating more
                    }

                    var updatedEntry = UpdateEntry(previousEntry, playerRatingChange);
                    updatedEntries.Add(updatedEntry);
                }
            }

            // Fill it
            var updatedPlayers = playingTeams.SelectMany(t => t.Players).ToHashSet();
            var oldEntries = leaderboard.Rows.Where(r => !updatedPlayers.Contains(r.Player()));

            var newLeaderboard = new Leaderboard
            {
                Time = DateTime.Now,
                Bracket = this.Bracket,
                Rows = oldEntries.Union(updatedEntries).ToArray()
            };

            newLeaderboard.Order();
            return newLeaderboard;
        }

        Dictionary<Leaderboard, HashSet<Team>> GenerateHistory(Team[] teams, LeaderboardEntry[] startingEntries, int length, int nGamesBefore)
        {
            var leaderboard = CreateLeaderboard(startingEntries);

            // make all teams play X games before simulation
            for (int i = 0; i < nGamesBefore; ++i)
            {
                leaderboard = Play(leaderboard, teams, team => Rng.Next(-30, 30));
            }
            
            // recorded simulation history
            var results = new Dictionary<Leaderboard, HashSet<Team>>();
            results[leaderboard] = new HashSet<Team>();

            for (int i = 0; i < length; ++i)
            {
                // Select subset of teams that will play
                int nTeamsPlayedThisTurn = 5;// 8 + Rng.Next(4);

                Team[] playingTeams = teams.Shuffle(Rng).Take(nTeamsPlayedThisTurn).ToArray();

                bool win = Rng.Next(2) == 0;

                // For each of them generate rating change, update players and create new leaderboard
                var newLeaderboard = Play(leaderboard, playingTeams, team => win
                        ? Rng.Next(-30, -10)
                        : Rng.Next(10, 30));
                
                // Remember who really played this turn
                results[newLeaderboard] = playingTeams.ToHashSet();

                leaderboard = newLeaderboard;
            }

            return results;
        }

        public double Distance(double[] a, double[] b)
        {
            return 0;
        }

        readonly static Dictionary<string, IKMeans<PlayerDiff>> Clusterers = new Dictionary<string,IKMeans<PlayerDiff>>
        {
            {"Accord no normalization", new AccordKMeans(normalize: false)},
            {"Accord with normalization", new AccordKMeans(normalize: true)},
            {"Numl non-normalized Manhattan distance", new NumlKMeans(new numl.Math.Metrics.ManhattanDistance())},
            {"Numl non-normalized Euclidean distance", new NumlKMeans(new numl.Math.Metrics.EuclidianDistance())},
            {"Numl non-normalized Hamming distance", new NumlKMeans(new numl.Math.Metrics.HammingDistance())},
            {"Numl non-normalized Cosine distance", new NumlKMeans(new numl.Math.Metrics.CosineDistance())},
        };

        [Test]
        [TestMethod]
        public void CalculateDerivationAccuracy()
        {
            LeaderboardEntry[] startingEntries = GeneratePlayers(1000);
            Team[] teams = GenerateTeams(startingEntries);
            var history = GenerateHistory(teams, startingEntries, length: 500, nGamesBefore: 40);

            foreach (var clusterer in Clusterers)
            {
                int totalChanges = 0;
                int correctlyDerived = 0;

                var previousLeaderboard = history.First().Key;

                foreach (var step in history.Skip(1))
                {
                    var leaderboard = step.Key;
                    var expectedTeams = step.Value;

                    totalChanges += expectedTeams.Count;

                    var cassandra = new Cassandra(clusterer.Value);
                    var derivedTeams = cassandra.FindTeams(previousLeaderboard, leaderboard);

                    correctlyDerived += derivedTeams.Intersect(expectedTeams).Count();

                    previousLeaderboard = leaderboard;
                }

                double accuracy = correctlyDerived / (double)totalChanges;
                string msg = string.Format("Cassandra accuracy with {0}: {0:F2}%", accuracy * 100);
                Trace.WriteLine(msg);
            }
        }
    }
}
