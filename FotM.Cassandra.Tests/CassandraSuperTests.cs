using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using FotM.Domain;
using FotM.TestingUtilities;
using FotM.Utilities;
using MoreLinq;
using NUnit.Framework;
using Microsoft.VisualStudio.TestTools.UnitTesting;

namespace FotM.Cassandra.Tests
{
    /// <summary>
    /// This class will test prediction(derivation?) accuracy of Cassandra based on 
    /// autogenerated history.
    /// </summary>
    [TestFixture]
    [TestClass]
    public class CassandraSuperTests: ArmoryTestingBase
    {
        const int TeamSize = 3;
        private readonly Random _rng = new Random(367);

        private readonly Realm[] _realms = new Realm[]
        {
            new Realm() { RealmId = 0, RealmSlug = "0", RealmName = "Zero"},
            new Realm() { RealmId = 1, RealmSlug = "1", RealmName = "Two"},
            new Realm() { RealmId = 2, RealmSlug = "2", RealmName = "Three"},
            new Realm() { RealmId = 3, RealmSlug = "3", RealmName = "Four"},
            new Realm() { RealmId = 4, RealmSlug = "4", RealmName = "Five"},
        };

        public CassandraSuperTests() : base(Bracket.Threes)
        {
        }

        LeaderboardEntry[] GeneratePlayers(int nPlayers)
        {
            return Enumerable.Range(0, nPlayers)
                .Select(i =>
                {
                    int nRealm = _rng.Next(5);

                    return new LeaderboardEntry()
                    {
                        ClassId = _rng.Next(10),
                        FactionId = 0,
                        GenderId = _rng.Next(2),
                        RaceId = _rng.Next(5),
                        Name = Guid.NewGuid().ToString(),
                        Ranking = _rng.Next(1, 1000),
                        Rating = _rng.Next(1900, 2400),
                        RealmId = _realms[nRealm].RealmId,
                        RealmName = _realms[nRealm].RealmName,
                        RealmSlug = _realms[nRealm].RealmSlug,
                        WeeklyWins = _rng.Next(10),
                        WeeklyLosses = _rng.Next(10),
                        SeasonLosses = 10+_rng.Next(50),
                        SeasonWins = 10+_rng.Next(50)
                    };
                })
                .ToArray();
        }

        Team[] GenerateTeams(LeaderboardEntry[] entries)
        {
            /* Generate teams from players of the same realm */
            var playersPerRealm = entries
                .Select(e => e.Player())
                .GroupBy(p => p.Realm);

            List<Team> teams = new List<Team>();

            foreach (var realm in playersPerRealm)
            {
                var players = realm.Shuffle(_rng).ToArray();

                int nTeams = players.Length / TeamSize;

                for (int i = 0; i < nTeams; ++i)
                {
                    var teamPlayers = new List<Player>();

                    for (int j = 0; j < TeamSize; ++j)
                    {
                        teamPlayers.Add(players[i * TeamSize + j]);
                    }

                    teams.Add(new Team(teamPlayers));
                }
            }

            return teams.ToArray();
        }

        Dictionary<Leaderboard, HashSet<Team>> GenerateHistory(Team[] teams, LeaderboardEntry[] startingEntries, int length)
        {
            var leaderboard = CreateLeaderboard(startingEntries);

            var results = new Dictionary<Leaderboard, HashSet<Team>>();
            results[leaderboard] = new HashSet<Team>();

            for (int i = 0; i < length; ++i)
            {
                // Select subset of teams that will play
                int nTeamsPlayedThisTurn = 8+_rng.Next(4);

                Team[] playingTeams = teams.Shuffle(_rng).Take(nTeamsPlayedThisTurn).ToArray();

                // For each of them generate rating change, update players and create new leaderboard
                var updatedEntries = new List<LeaderboardEntry>();

                foreach (var playingTeam in playingTeams)
                {
                    var previousPlayerEntries =
                        playingTeam.Players.Select(
                            player => leaderboard.Rows.FirstOrDefault(r => r.Player().Equals(player)))
                            .OrderByDescending(p => p.Rating)
                            .ToArray();

                    int teamRatingChange = _rng.Next(-30, 30);

                    for (int iPlayer = 0; iPlayer < TeamSize; ++iPlayer)
                    {
                        var previousEntry = previousPlayerEntries[iPlayer];

                        // higher rated players gain less rating and lose more
                        int ratingChange = teamRatingChange;

                        if (ratingChange > 0)
                        {
                            ratingChange += iPlayer; // add 0, 1 or 2
                        }
                        else
                        {
                            ratingChange -= TeamSize-iPlayer; // decrease rating more
                        }

                        var updatedEntry = UpdateEntry(previousEntry, ratingChange);
                        updatedEntries.Add(updatedEntry);
                    }
                }

                // Fill it
                var updatedPlayers = playingTeams.SelectMany(t => t.Players).ToHashSet();
                var oldEntries = leaderboard.Rows.Where(r => !updatedPlayers.Contains(r.Player()));

                var newLeaderboard = new Leaderboard
                {
                    Time = DateTime.Now, 
                    Bracket = this.Bracket,
                    Rows = oldEntries.Union(updatedEntries).ToArray()
                };

                newLeaderboard.Order();

                // Remember who really played this turn
                results[newLeaderboard] = playingTeams.ToHashSet();

                leaderboard = newLeaderboard;
            }

            return results;
        }

        public double Distance(double[] a, double[] b)
        {
        }

        readonly IKMeans<PlayerDiff> _kmeans = 
            new AccordKMeans();
            //new NumlKMeans(new numl.Math.Metrics.HammingDistance());

        [Test]
        [TestMethod]
        public void CalculateDerivationAccuracy()
        {
            LeaderboardEntry[] startingEntries = GeneratePlayers(1000);
            Team[] teams = GenerateTeams(startingEntries);
            var history = GenerateHistory(teams, startingEntries, 500);

            int totalChanges = 0;
            int correctlyDerived = 0;

            var previousLeaderboard = history.First().Key;

            foreach (var step in history.Skip(1))
            {
                var leaderboard = step.Key;
                var expectedTeams = step.Value;

                totalChanges += expectedTeams.Count;

                var cassandra = new Cassandra(_kmeans);
                var derivedTeams = cassandra.FindTeams(previousLeaderboard, leaderboard);

                correctlyDerived += derivedTeams.Intersect(expectedTeams).Count();

                previousLeaderboard = leaderboard;
            }

            double accuracy = correctlyDerived/(double) totalChanges;
            string msg = string.Format("Cassandra accuracy: {0:F2}%", accuracy*100);
            Trace.WriteLine(msg);
        }
    }
}
